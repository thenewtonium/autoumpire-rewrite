"""
Assassin.py

Defines the ORM model `Assassin` representing the instance of an assassin in a game.
An 'assassin' here means a full player -- i.e. a player with targets and a competence deadline.
"""

from typing import List, Optional
from .Player import Player
from .TargRel import TargRel
from sqlalchemy import ForeignKey, DateTime
from sqlalchemy.orm import Mapped, mapped_column, relationship
from datetime import datetime

class Assassin(Player):
    """
    Assassin class

    Extends the Player class by including vitality, competence, and targetting relationships.
    """

    __tablename__ = "assassins"
    id = mapped_column(ForeignKey(Player.id), primary_key=True)

    alive: Mapped[bool] = mapped_column(default=True)
    competence_deadline: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True), nullable=True)

    # lists of targets and assassins generated by persisting a relationship using a secondary join with targetting_table
    targets: Mapped[List["Assassin"]] = relationship(overlaps="assassins,target,assassin",
                                                     secondary=TargRel.__tablename__,
                                                     primaryjoin="Assassin.id==TargRel.assassin_id",
                                                     secondaryjoin="Assassin.id==TargRel.target_id")
    assassins: Mapped[List["Assassin"]] = relationship(overlaps="targets,assassin,target",
                                                       secondary=TargRel.__tablename__,
                                                       primaryjoin="Assassin.id==TargRel.target_id",
                                                       secondaryjoin="Assassin.id==TargRel.assassin_id")

    __mapper_args__ = {
        "polymorphic_identity": "assassin", # sets Player.type for objects of this class to "assassin"
    }

    # TODO: event-based structure for targets, so we have a 'wanted at'
    #  Maybe a a bit overwrought but allows us to track targetting!
    def licit_for(self, killer: Player) -> bool:
        # TODO: check for wantedness/incompetence
        if isinstance(killer, Assassin):
            if self in killer.targets:
                return (True, f'because {self.id} is a target of {killer.id}')
            if self in killer.assassins:
                return (True, f'because {self.id} is targetting {killer.id}')
            return (False, f'because {self.id} is neither a target of nor targetting {killer.id}')

    def send_update(self, body: str = ""):
        from .templates import env
        from babel.dates import format_datetime
        template = env.get_template("update-email.jinja")
        message = template.render(player=self.reg,
                                  message=body,
                                  targets=[t.reg for t in self.targets],
                                  competence_deadline=format_datetime(self.competence_deadline,
                                                                      locale=self.game.locale,
                                                                      tzinfo=self.competence_deadline.tzinfo
                                                                      )
                                  )
        self.reg.send_email(body=message)